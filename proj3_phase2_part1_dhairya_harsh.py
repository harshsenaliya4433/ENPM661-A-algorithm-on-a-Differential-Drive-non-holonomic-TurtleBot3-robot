# -*- coding: utf-8 -*-
"""Proj3_phase2_part1_Dhairya_Harsh.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vPabfxmNe1Icv4I8yK90t4ViRzbAWrnI
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import heapq
from math import dist
import matplotlib.patches as patches
import time

class Plotter:
    def __init__(self):
        self.figure, self.axes = plt.subplots()
        self.axes.set(xlim=(0, 6000), ylim=(0, 2000))
        self.obstacle1 = plt.Circle((4000, 1100), 500, fill=True, color='red')
        self.obstacle2 = patches.Rectangle((1500, 750), 150, 1250, color='red')
        self.obstacle3 = patches.Rectangle((2500, 0), 150, 1250, color='red')
        self.axes.set_aspect('equal')
        self.axes.add_artist(self.obstacle1)
        self.axes.add_artist(self.obstacle2)
        self.axes.add_patch(self.obstacle3)
        self.explored_scatter = None
        self.path_line = None

    def plot_start_and_goal(self, start_node, goal_node):
        self.axes.plot(start_node.x, start_node.y, "Dg")
        self.axes.plot(goal_node.x, goal_node.y, "Dg")

    def update_plot(self, Nodes_list, Path_list):
        if self.explored_scatter is not None:
            self.explored_scatter.remove()
        x_values, y_values = zip(*Nodes_list)
        self.explored_scatter = self.axes.scatter(x_values, y_values, color='yellow')

        if self.path_line is not None:
            self.path_line.remove()
        if Path_list:
            path_x, path_y = zip(*Path_list)
            self.path_line, = self.axes.plot(path_x, path_y, '-b')

    def plot_backtrack_path(self, backtrack_path):
        if self.path_line is not None:
            self.path_line.remove()
        if backtrack_path:
            backtrack_x, backtrack_y = zip(*backtrack_path)
            self.path_line, = self.axes.plot(backtrack_x, backtrack_y, '-g')
        plt.show()

class Node:
    def __init__(self, x, y, parent, current_theta, change_theta, UL, UR, c2c, c2g, total_cost):
        self.x = x
        self.y = y
        self.parent = parent
        self.current_theta = current_theta
        self.change_theta = change_theta
        self.UL = UL
        self.UR = UR
        self.c2c = c2c
        self.c2g = c2g
        self.total_cost = total_cost

    def __lt__(self, other):
        return self.total_cost < other.total_cost

def plot_curve(Xi, Yi, Thetai, UL, UR, c, plot, Nodes_list, Path_list):
    t = 0
    r = 40
    L = 160
    dt = 0.1
    cost = 0
    X_end = Xi
    Y_end = Yi
    Theta_end = math.pi * Thetai / 180

    while t < 1:
        t = t + dt
        X_start = X_end
        Y_start = Y_end
        X_end += r * 0.5 * (UL + UR) * math.cos(Theta_end) * dt
        Y_end += r * 0.5 * (UL + UR) * math.sin(Theta_end) * dt
        Theta_end += (r / L) * (UR - UL) * dt

        if valid_move(X_end, Y_end, r, c):
            if plot == 0:
                Nodes_list.append((X_end, Y_end))
                Path_list.append((X_start, Y_start))
            if plot == 1:
                plt.plot([X_start, X_end], [Y_start, Y_end], color="red")
        else:
            return None
    Theta_end = 180 * (Theta_end) / math.pi
    return [X_end, Y_end, Theta_end, cost, Nodes_list, Path_list]

def key(node):
    key = 1000 * node.x + 111 * node.y
    return key